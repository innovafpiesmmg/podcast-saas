import { MediaAsset, InsertMediaAsset } from "@shared/schema";
import path from "path";
import crypto from "crypto";
import fs from "fs/promises";
import { drive_v3, google } from "googleapis";
import type { Readable } from "stream";
import { Readable as ReadableStream } from "stream";

// Lightweight upload metadata (no id/createdAt - those are generated by DB)
export interface UploadMetadata {
  ownerId: string;
  podcastId: string | null;
  episodeId: string | null;
  type: "COVER_ART" | "EPISODE_AUDIO";
  storageProvider: "LOCAL" | "GOOGLE_DRIVE";
  storageKey: string;
  publicUrl: string | null;
  mimeType: string;
  sizeBytes: number;
  checksum: string | null;
  visibility: string;
  status: "DRAFT" | "PENDING_APPROVAL" | "APPROVED" | "REJECTED";
}

// Storage adapter interface
export interface StorageAdapter {
  saveCoverArt(file: Express.Multer.File, ownerId: string, podcastId?: string): Promise<UploadMetadata>;
  saveEpisodeAudio(file: Express.Multer.File, ownerId: string, episodeId?: string, podcastId?: string): Promise<UploadMetadata>;
  getPublicUrl(asset: MediaAsset): string;
  getSignedUrl(asset: MediaAsset, expiresInSeconds?: number): Promise<string>;
  deleteAssetByKey(storageKey: string): Promise<void>;
  streamAsset(asset: MediaAsset): Promise<Readable>;
}

// Local storage adapter - stores files in uploads/ directory
export class LocalStorageAdapter implements StorageAdapter {
  private uploadsDir = path.join(process.cwd(), "uploads");

  async saveCoverArt(file: Express.Multer.File, ownerId: string, podcastId?: string): Promise<UploadMetadata> {
    const filename = this.generateFilename(file.originalname);
    const storagePath = `images/${filename}`;
    const fullPath = path.join(this.uploadsDir, storagePath);

    // Ensure directory exists
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Move file to destination
    await fs.writeFile(fullPath, file.buffer);

    // Calculate checksum
    const checksum = crypto.createHash("md5").update(file.buffer).digest("hex");

    return {
      ownerId,
      podcastId: podcastId || null,
      episodeId: null,
      type: "COVER_ART",
      storageProvider: "LOCAL",
      storageKey: storagePath,
      publicUrl: `/media/images/${filename}`,
      mimeType: file.mimetype,
      sizeBytes: file.size,
      checksum,
      visibility: "public",
      status: "APPROVED",
    };
  }

  async saveEpisodeAudio(file: Express.Multer.File, ownerId: string, episodeId?: string, podcastId?: string): Promise<UploadMetadata> {
    const filename = this.generateFilename(file.originalname);
    const storagePath = `audio/${filename}`;
    const fullPath = path.join(this.uploadsDir, storagePath);

    // Ensure directory exists
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Move file to destination
    await fs.writeFile(fullPath, file.buffer);

    // Calculate checksum
    const checksum = crypto.createHash("md5").update(file.buffer).digest("hex");

    return {
      ownerId,
      podcastId: podcastId || null,
      episodeId: episodeId || null,
      type: "EPISODE_AUDIO",
      storageProvider: "LOCAL",
      storageKey: storagePath,
      publicUrl: `/media/audio/${filename}`,
      mimeType: file.mimetype,
      sizeBytes: file.size,
      checksum,
      visibility: "public",
      status: "APPROVED",
    };
  }

  getPublicUrl(asset: MediaAsset): string {
    return asset.publicUrl || `/media/${asset.storageKey}`;
  }

  async getSignedUrl(asset: MediaAsset, expiresInSeconds: number = 3600): Promise<string> {
    // For local storage, we don't need signed URLs
    // Return the public URL instead
    return this.getPublicUrl(asset);
  }

  async deleteAssetByKey(storageKey: string): Promise<void> {
    const fullPath = path.join(this.uploadsDir, storageKey);
    try {
      await fs.unlink(fullPath);
    } catch (error) {
      console.error(`Error deleting file ${fullPath}:`, error);
      // Don't throw - file might already be deleted
    }
  }

  async streamAsset(asset: MediaAsset): Promise<Readable> {
    const fullPath = path.join(this.uploadsDir, asset.storageKey);
    
    try {
      await fs.access(fullPath);
    } catch (error) {
      throw new Error(`File not found: ${asset.storageKey}`);
    }
    
    const { createReadStream } = await import("fs");
    return createReadStream(fullPath);
  }

  private generateFilename(originalName: string): string {
    const ext = path.extname(originalName);
    const timestamp = Date.now();
    const random = crypto.randomBytes(8).toString("hex");
    return `${timestamp}-${random}${ext}`;
  }
}

// Google Drive storage adapter
export class DriveStorageAdapter implements StorageAdapter {
  private drive: drive_v3.Drive | null = null;
  private serviceAccountEmail: string;
  private serviceAccountKey: string;
  private folderIdImages: string;
  private folderIdAudio: string;

  constructor(config: {
    serviceAccountEmail: string;
    serviceAccountKey: string;
    folderIdImages: string;
    folderIdAudio: string;
  }) {
    this.serviceAccountEmail = config.serviceAccountEmail;
    this.serviceAccountKey = config.serviceAccountKey;
    this.folderIdImages = config.folderIdImages;
    this.folderIdAudio = config.folderIdAudio;
  }

  private async getDrive(): Promise<drive_v3.Drive> {
    if (this.drive) {
      return this.drive;
    }

    const auth = new google.auth.GoogleAuth({
      credentials: JSON.parse(this.serviceAccountKey),
      scopes: ["https://www.googleapis.com/auth/drive"],
    });

    this.drive = google.drive({ version: "v3", auth });
    return this.drive;
  }

  async saveCoverArt(file: Express.Multer.File, ownerId: string, podcastId?: string): Promise<UploadMetadata> {
    const drive = await this.getDrive();
    const filename = this.generateFilename(file.originalname);

    // Convert buffer to stream
    const bufferStream = ReadableStream.from(file.buffer);

    // Upload to Google Drive
    const response = await drive.files.create({
      requestBody: {
        name: filename,
        parents: [this.folderIdImages],
      },
      media: {
        mimeType: file.mimetype,
        body: bufferStream,
      },
      fields: "id, webViewLink, webContentLink",
    });

    const fileId = response.data.id!;
    const checksum = crypto.createHash("md5").update(file.buffer).digest("hex");

    // Make file publicly accessible
    await drive.permissions.create({
      fileId,
      requestBody: {
        role: "reader",
        type: "anyone",
      },
    });

    return {
      ownerId,
      podcastId: podcastId || null,
      episodeId: null,
      type: "COVER_ART",
      storageProvider: "GOOGLE_DRIVE",
      storageKey: fileId,
      publicUrl: `https://drive.google.com/uc?id=${fileId}&export=download`,
      mimeType: file.mimetype,
      sizeBytes: file.size,
      checksum,
      visibility: "public",
      status: "APPROVED",
    };
  }

  async saveEpisodeAudio(file: Express.Multer.File, ownerId: string, episodeId?: string, podcastId?: string): Promise<UploadMetadata> {
    const drive = await this.getDrive();
    const filename = this.generateFilename(file.originalname);

    // Convert buffer to stream
    const bufferStream = ReadableStream.from(file.buffer);

    // Upload to Google Drive
    const response = await drive.files.create({
      requestBody: {
        name: filename,
        parents: [this.folderIdAudio],
      },
      media: {
        mimeType: file.mimetype,
        body: bufferStream,
      },
      fields: "id, webViewLink, webContentLink",
    });

    const fileId = response.data.id!;
    const checksum = crypto.createHash("md5").update(file.buffer).digest("hex");

    // Make file publicly accessible
    await drive.permissions.create({
      fileId,
      requestBody: {
        role: "reader",
        type: "anyone",
      },
    });

    return {
      ownerId,
      podcastId: podcastId || null,
      episodeId: episodeId || null,
      type: "EPISODE_AUDIO",
      storageProvider: "GOOGLE_DRIVE",
      storageKey: fileId,
      publicUrl: `https://drive.google.com/uc?id=${fileId}&export=download`,
      mimeType: file.mimetype,
      sizeBytes: file.size,
      checksum,
      visibility: "public",
      status: "APPROVED",
    };
  }

  getPublicUrl(asset: MediaAsset): string {
    return asset.publicUrl || `https://drive.google.com/uc?id=${asset.storageKey}&export=download`;
  }

  async getSignedUrl(asset: MediaAsset, expiresInSeconds: number = 3600): Promise<string> {
    // Google Drive public links don't expire
    return this.getPublicUrl(asset);
  }

  async deleteAssetByKey(storageKey: string): Promise<void> {
    const drive = await this.getDrive();
    try {
      await drive.files.delete({
        fileId: storageKey,
      });
    } catch (error) {
      console.error(`Error deleting Google Drive file ${storageKey}:`, error);
      // Don't throw - file might already be deleted
    }
  }

  async streamAsset(asset: MediaAsset): Promise<Readable> {
    const drive = await this.getDrive();
    const response = await drive.files.get(
      {
        fileId: asset.storageKey,
        alt: "media",
      },
      { responseType: "stream" }
    );

    return response.data as unknown as Readable;
  }

  private generateFilename(originalName: string): string {
    const ext = path.extname(originalName);
    const timestamp = Date.now();
    const random = crypto.randomBytes(8).toString("hex");
    return `${timestamp}-${random}${ext}`;
  }
}

// Storage service factory
export class StorageService {
  private adapter: StorageAdapter;

  constructor(adapter?: StorageAdapter) {
    // Default to local storage if no adapter provided
    this.adapter = adapter || new LocalStorageAdapter();
  }

  static async createFromConfig(driveConfig?: {
    serviceAccountEmail: string;
    serviceAccountKey: string;
    folderIdImages: string;
    folderIdAudio: string;
    isActive: boolean;
  }): Promise<StorageService> {
    if (driveConfig && driveConfig.isActive) {
      const adapter = new DriveStorageAdapter(driveConfig);
      return new StorageService(adapter);
    }

    return new StorageService(new LocalStorageAdapter());
  }

  async saveCoverArt(file: Express.Multer.File, ownerId: string, podcastId?: string): Promise<UploadMetadata> {
    return this.adapter.saveCoverArt(file, ownerId, podcastId);
  }

  async saveEpisodeAudio(file: Express.Multer.File, ownerId: string, episodeId?: string, podcastId?: string): Promise<UploadMetadata> {
    return this.adapter.saveEpisodeAudio(file, ownerId, episodeId, podcastId);
  }

  getPublicUrl(asset: MediaAsset): string {
    return this.adapter.getPublicUrl(asset);
  }

  async getSignedUrl(asset: MediaAsset, expiresInSeconds?: number): Promise<string> {
    return this.adapter.getSignedUrl(asset, expiresInSeconds);
  }

  async deleteAsset(asset: MediaAsset | UploadMetadata): Promise<void> {
    // Route to the correct adapter based on the asset's storage provider
    if (asset.storageProvider === "GOOGLE_DRIVE") {
      try {
        // Get drive config and create Drive adapter
        const driveConfig = await import("./storage").then(m => m.storage.getActiveDriveConfig());
        const config = await driveConfig;
        if (!config) {
          console.warn(`Cannot delete Google Drive asset ${asset.storageKey}: no active Drive configuration. Asset may be orphaned.`);
          return; // Gracefully handle missing config
        }
        const driveAdapter = new DriveStorageAdapter(config);
        await driveAdapter.deleteAssetByKey(asset.storageKey);
      } catch (error) {
        console.error(`Failed to delete Google Drive asset ${asset.storageKey}:`, error);
        // Don't throw - log error but don't block cleanup
      }
    } else {
      // Use local adapter
      try {
        const localAdapter = new LocalStorageAdapter();
        await localAdapter.deleteAssetByKey(asset.storageKey);
      } catch (error) {
        console.error(`Failed to delete local asset ${asset.storageKey}:`, error);
        // Don't throw - log error but don't block cleanup
      }
    }
  }

  async streamAsset(asset: MediaAsset): Promise<Readable> {
    return this.adapter.streamAsset(asset);
  }
}

// ===================================================
// API Service Functions - Episode & Podcast Enrichment
// ===================================================

import { storage } from "./storage";
import { enrichEpisodeWithArtwork, resolveEpisodeArtwork, resolveEpisodeAudioUrl } from "./serializers/episode";
import type { Episode, Podcast } from "@shared/schema";

/**
 * Fetches a single episode with enriched cover art and subscription status.
 * Returns episode with effectiveCoverArtUrl/AssetId fields.
 */
export async function fetchEpisodeForApi(episodeId: string, viewerId?: string) {
  const episode = await storage.getEpisodeWithPodcast(episodeId);
  if (!episode) return undefined;
  
  const podcast = await storage.getPodcast(episode.podcastId);
  if (!podcast) return undefined;
  
  const enriched = enrichEpisodeWithArtwork(episode, podcast);
  const isSubscribed = viewerId ? await storage.isSubscribed(viewerId, episode.podcastId) : false;
  
  return { ...enriched, isSubscribed };
}

/**
 * Fetches a podcast with its episodes, enriching each episode with effective cover art.
 */
export async function fetchPodcastWithEpisodesForApi(podcastId: string, viewerId?: string) {
  const podcast = await storage.getPodcast(podcastId);
  if (!podcast) return undefined;
  
  const episodes = await storage.getEpisodesByPodcast(podcastId);
  
  // Enrich each episode with effective cover art and audio URL
  const enrichedEpisodes = await Promise.all(
    episodes.map(async (episode) => {
      // Resolve cover art
      const { coverArtUrl, coverArtAssetId } = resolveEpisodeArtwork(episode, podcast);
      
      // Resolve audio URL from asset if needed
      let audioAsset = null;
      if (episode.audioAssetId && !episode.audioUrl) {
        audioAsset = await storage.getMediaAsset(episode.audioAssetId);
      }
      const audioUrl = resolveEpisodeAudioUrl(episode, audioAsset);
      
      return {
        ...episode,
        audioUrl,
        effectiveCoverArtUrl: coverArtUrl,
        effectiveCoverArtAssetId: coverArtAssetId,
      };
    })
  );
  
  const isSubscribed = viewerId ? await storage.isSubscribed(viewerId, podcastId) : false;
  
  return {
    ...podcast,
    episodes: enrichedEpisodes,
    isSubscribed,
  };
}

/**
 * Comprehensive helper for episode API responses.
 * Fetches episode with podcast, performs access control, enriches with cover art,
 * and generates canonical URLs/embed code.
 * 
 * @returns null if not found, or { episode, podcast, hasAccess } with enriched data
 */
export async function getEpisodeForResponse(
  episodeId: string,
  viewerId?: string,
  userRole?: string
): Promise<{
  episode: Episode & {
    effectiveCoverArtUrl: string | null;
    effectiveCoverArtAssetId: string | null;
    isSubscribed: boolean;
  };
  podcast: Podcast | null;
  hasAccess: boolean;
} | null> {
  // Fetch episode with podcast
  const episode = await storage.getEpisodeWithPodcast(episodeId);
  if (!episode) return null;
  
  // Try to fetch podcast (may be missing in edge cases)
  const podcast = await storage.getPodcast(episode.podcastId);
  
  // Determine access - check both visibility/invitations and moderation status
  // Check visibility access (PRIVATE/UNLISTED/PUBLIC + invitations)
  const hasVisibilityAccess = await storage.checkUserHasAccessToEpisode(viewerId, episodeId);
  
  // Check moderation access (APPROVED status or owner/admin)
  let hasModerationAccess = episode.status === "APPROVED";
  if (viewerId && userRole) {
    const isAdmin = userRole === "ADMIN";
    // Admin can always access, even if podcast is missing
    if (isAdmin) {
      hasModerationAccess = true;
    } else if (podcast) {
      // Owner can access if podcast exists and they own it
      const isOwner = podcast.ownerId === viewerId;
      hasModerationAccess = hasModerationAccess || isOwner;
    }
  }
  
  // Final access requires BOTH visibility and moderation access
  const hasAccess = hasVisibilityAccess && hasModerationAccess;
  
  // Fetch audio asset if episode has audioAssetId but no audioUrl
  let audioAsset = null;
  if (episode.audioAssetId && !episode.audioUrl) {
    audioAsset = await storage.getMediaAsset(episode.audioAssetId);
  }
  
  // Resolve audio URL from asset if needed
  const audioUrl = resolveEpisodeAudioUrl(episode, audioAsset);
  
  // Enrich episode with effective cover art (use podcast if available)
  let enriched;
  if (podcast) {
    enriched = enrichEpisodeWithArtwork(episode, podcast);
  } else {
    // No podcast available - use episode's own cover art only
    enriched = {
      ...episode,
      effectiveCoverArtUrl: episode.coverArtUrl,
      effectiveCoverArtAssetId: episode.coverArtAssetId,
    };
  }
  
  // Get subscription status
  const isSubscribed = viewerId ? await storage.isSubscribed(viewerId, episode.podcastId) : false;
  
  return {
    episode: { ...enriched, audioUrl, isSubscribed },
    podcast: podcast || null,
    hasAccess,
  };
}
